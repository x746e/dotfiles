. ~/.zshrc.local

# Search path for the cd command
#cdpath=(.. ~ ~/src ~/zsh)

## useful bindkey macros
bindkey -s "^Xm" 'mutt\n' ## run mutt
#!! bindkey -s "^Xc" 'mcdrom\n' ## mount or umount cdrom
#!! bindkey -s "^Xf" 'mflash\n' ## mount or umount flash

umask 022

# Set up aliases
alias v='less'                ##TODO: script for viewing different file types
alias vv='vim -R'
alias mv='nocorrect mv'       # no spelling correction on mv
alias cp='nocorrect cp'       # no spelling correction on cp
alias mkdir='nocorrect mkdir' # no spelling correction on mkdir
alias rm='rm -I'
alias j=jobs
alias pu=pushd
alias po=popd
alias d='dirs -v'
alias grep=egrep --colour
alias vlm='less /var/log/messages'
alias bc='bc -l'
alias tt='tail -F'
alias pL='ps auxww|less'
alias la='l -a'
alias lla='ll -a'
alias bkd='date +%FT%H%M'
case `uname` in
    "Linux"|CYGWIN*)
        alias ll='ls -lF --color=auto'
        alias l='ls -FG --color=auto'
        alias sed='sed -r'
        ;;
    *)
        alias ll='ls -lFG'
        alias l='ls -FG'
        alias sed='sed -E'
        ;;
esac
alias mq='hg -R $(hg root)/.hg/patches'
alias hdfs='hadoop dfs'
alias nhive='/usr/local/bin/hive --namespace'
#alias -g sd='export DISPLAY='

# List only directories and symbolic
# links that point to directories
alias lsd='ls -ld *(-/DN)'

# List only file beginning with "."
alias lsa='ls -ld .*'

alias tpp='cd ~/mfiles/transproject/transproject && source ../venv/bin/activate'

# Shell functions
setenv() { typeset -x "${1}${1:+=}${(@)argv[2,$#]}" }  # csh compatibility
freload() { while (( $# )); do; unfunction $1; autoload -U $1; shift; done }

# Where to look for autoloaded function definitions
fpath=($fpath ~/.zfunc)
autoload -U zfinit

# Autoload all shell functions from all directories in $fpath (following
# symlinks) that have the executable bit on (the executable bit is not
# necessary, but gives you an easy way to stop the autoloading of a
# particular shell function). $fpath should not be empty for this to work.
for func in $^fpath/*(N-.x:t); autoload $func

# automatically remove duplicates from these arrays
typeset -U path cdpath fpath manpath

# Global aliases -- These do not have to be
# at the beginning of the command line.
alias -g L='|less'
alias -g L2=' 2>&1 |less'
alias -g Lj='| python -mjson.tool'
alias -g H='|head'
alias -g T='|tail'
alias -g G='|egrep --colour'
alias -g Gv='|egrep -v --colour'
alias -g Gi='|egrep -i --colour'
alias -g W='|wc -lwm'
alias -g Wl='|wc -l'
alias -g Bg=' >/dev/null 2>&1 &!'
alias -g D='; notify-send "$history[$HISTCMD]ONE" "exit-code: $?"'
alias -g C1='| awk ''{print $1}'''
alias -g C2='| awk ''{print $2}'''
alias -g C3='| awk ''{print $3}'''
alias -g C4='| awk ''{print $4}'''
alias -g C5='| awk ''{print $5}'''
alias -g C6='| awk ''{print $6}'''
alias -g C7='| awk ''{print $7}'''
alias -g S='|sort'
alias -g U='|sort -u'
alias -g ...='../..'
alias -g ....='../../..'
alias -g .....='../../../..'

case `uname` in
    "DragonFly")
        manpath=(/usr/X11R6/man /usr/man /usr/lang/man /usr/pkg/man /usr/share/man) ;;
    "Darwin")
        manpath=(/usr/X11R6/man /usr/man /usr/lang/man /usr/local/man /usr/share/man /opt/local/man)
        PATH="$PATH:/opt/local/bin:/opt/local/sbin" ;;
    CYGWIN*)
        PATH="$PATH:/cygdrive/c/Program Files/Wireshark:/cygdrive/c/Program Files/nodejs:/cygdrive/c/mvn3.2.3/bin:/cygdrive/c/emacs/bin:/cygdrive/c/Program Files (x86)/scala/bin/" ;;
    *)
        manpath=(/usr/X11R6/man /usr/man /usr/lang/man /usr/local/man /usr/share/man) ;;
esac
export MANPATH

export PATH="$PATH:$HOME/bin"

# Hosts to use for completion (see later zstyle)
local hosts
#hosts=( ${${${${(f)"$(<$HOME/.ssh/known_hosts)"}:#[0-9]*}%%\ *}%%,*} )
hosts=(0x746e.org.ua test-3.blikbook.com moodlebox jenkins)


# Set prompts

_DEFAULT_TMUX_WINDOW_TITLE="zsh"
_set-tmux-window-title () {
    echo -n "\033k$1\033\\"
}
_get-tmux-window-title () {
    tmux display-message -p '#W'
}
# A hook executed just after a command has been read and is about to be executed.
function preexec() {
    cmd_to_be_executed="$1"
    function async() {
        if [ "$(_get-tmux-window-title)" = "$_DEFAULT_TMUX_WINDOW_TITLE" ]; then
            _set-tmux-window-title "% $cmd_to_be_executed"
        fi
    }
    async &!
}
# A hook executed before each prompt.
precmd() {
    function async() {
        if [[ "$(_get-tmux-window-title)" =~ '^% .*$' ]]; then
            _set-tmux-window-title "$_DEFAULT_TMUX_WINDOW_TITLE"
        fi
    }
    async &!
    RPROMPT=""

    function async_prompt() {
        hg prompt --angle-brackets '%F{red}<branch> <%B[<bookmark>]%b >%f%F{yellow}%B<<tags> >%b%f%F{green}<status|modified|unknown><update>%f ' 2>/dev/null >| "$HOME/.zsh_tmp_prompt"
        kill -s USR1 $$
    }
    async_prompt &!
}
function TRAPUSR1() {
    # read from temp file
    RPROMPT="$(cat ${HOME}/.zsh_tmp_prompt)"

    # reset proc number
    # ASYNC_PROC=0

    # redisplay
    zle && zle reset-prompt
}


if false; then
    xset b off
fi

autoload -U promptinit
promptinit
## Currently available prompt themes:
## adam1 adam2 bart bigfade clint elite2 elite
## fade fire off oliver redhat suse walters zefram
# prompt adam1
##TODO
prompt mine black cyan cyan $HOST_PROMPT_COLOR

# Some environment variables
export SHELL='zsh'
export EDITOR='vim'
export MAIL=/var/mail/$USERNAME
# less settings:
# --RAW-CONTROL-CHARS is for show ANSI control sequences as colors.
export LESS="--ignore-case --quit-if-one-screen --LONG-PROMPT --RAW-CONTROL-CHARS"
export HELPDIR=/usr/local/lib/zsh/help  # directory for run-help function to find docs
export PAGER=less
#export EMAIL=tn@0x746e.org.ua
#export HGUSER=$EMAIL
if [ -e /usr/share/terminfo/x/xterm-256color ]; then
    export TERM='xterm-256color'
else
    export TERM='xterm-color'
fi

MAILCHECK=300
DIRSTACKSIZE=20

##
# History
HISTSIZE=50000
SAVEHIST=50000
HISTFILE="$HOME/.zsh_history"
setopt extended_history hist_expire_dups_first

_ISO_DATETIME_FORMAT='%Y-%m-%d %H:%M:%S'
_zsh_startup_time=$(date +"$_ISO_DATETIME_FORMAT")
alias hall="fc -t '$_ISO_DATETIME_FORMAT' -l 1 | less +G"
function h() { # Show history from this shell session only.
    fc -t "$_ISO_DATETIME_FORMAT" -l 1 | awk "{
        entry_time = \$2 \" \" \$3;
        if (entry_time >= \"$_zsh_startup_time\") {
            print
        }
    }"
}

# Set/unset shell options
setopt   nobeep
setopt   notify globdots correct pushdtohome cdablevars autolist
setopt   correctall autocd recexact longlistjobs
setopt   autoresume pushdsilent noclobber
setopt   autopushd pushdminus extendedglob rcquotes mailwarning
unsetopt bgnice autoparamslash

# Autoload zsh modules when they are referenced
zmodload -F zsh/stat b:zstat
zmodload -a zsh/zpty zpty
zmodload -a zsh/zprof zprof
zmodload -ap zsh/mapfile mapfile

# Some nice key bindings
#bindkey '^X^Z' universal-argument ' ' magic-space
#bindkey '^X^A' vi-find-prev-char-skip
#bindkey '^Xa' _expand_alias
#bindkey '^Z' accept-and-hold
#bindkey -s '\M-/' \\\\
#bindkey -s '\M-=' \|

# bindkey -v               # vi key bindings

bindkey -e                 # emacs key bindings
bindkey ' ' magic-space    # also do history expansion on space
bindkey '^I' complete-word # complete on tab, leave expansion to _expand


# Setup new style completion system. To see examples of the old style (compctl
# based) programmable completion, check Misc/compctl-examples in the zsh
# distribution.
autoload -U compinit
compinit -i



# Completion Styles

# list of completers to use
zstyle ':completion:*::::' completer _expand _complete _ignored _approximate

# allow one error for every three characters typed in approximate completer
zstyle -e ':completion:*:approximate:*' max-errors \
    'reply=( $(( ($#PREFIX+$#SUFFIX)/3 )) numeric )'

# insert all expansions for expand completer
zstyle ':completion:*:expand:*' tag-order all-expansions

# formatting and messages
zstyle ':completion:*' verbose yes
zstyle ':completion:*:descriptions' format '%B%d%b'
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format 'No matches for: %d'
zstyle ':completion:*:corrections' format '%B%d (errors: %e)%b'
zstyle ':completion:*' group-name ''

# match uppercase from lowercase
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# offer indexes before parameters in subscripts
zstyle ':completion:*:*:-subscript-:*' tag-order indexes parameters

# command for process lists, the local web server details and host completion
#zstyle ':completion:*:processes' command 'ps -o pid,s,nice,stime,args'
#zstyle ':completion:*:urls' local 'www' '/var/www/htdocs' 'public_html'
zstyle '*' hosts $hosts

# Filename suffixes to igbnore during completion (except after rm command)
zstyle ':completion:*:*:(^rm):*:*files' ignored-patterns '*?.o' '*?.c~' \
    '*?.old' '*?.pro'
# the same for old style completion
#fignore=(.o .c~ .old .pro)

#'
# ignore completion functions (until the _ignored completer)
zstyle ':completion:*:functions' ignored-patterns '_*'

#
# Misc Functions
#

ud () {
    if [ ! -z "$1" ]
    then
        python -c "import datetime; print datetime.datetime.fromtimestamp($1)"
    fi
}

# pG scripts
pG () {
    if [ -z "$1" ]; then
        ps auxww | less
    else
        ps auxww | fgrep -v grep | egrep --colour "($1|^USER.*)"
    fi
}
pGi () {
    if [ -z "$1" ]; then
        ps auxww | less
    else
        ps auxww | fgrep -v grep | egrep --ignore-case --colour "($1|^USER.*)"
    fi
}
pGp () {
    if [ ! -z "$1" ]; then
        ps auxww | awk "/$1/ && !/grep/ { print \$2 }"
    else
        echo "Usage: $0 pattern"
    fi
}
pGk () {
    if [ ! -z "$1" ]; then
        ps auxww | awk "/$1/ && !/grep/ { system(\"kill \"\$2) }"
    else
        echo "Usage: $0 pattern"
    fi
}
pG9 () {
    if [ ! -z "$1" ]; then
        ps auxww | awk "/$1/ && !/grep/ { system(\"kill -9 \"\$2) }"
    else
        echo "Usage: $0 pattern"
    fi
}
#
cman () {
    if [ ! -z "$1" ]; then
        groff -man -Tascii $1
    else
        echo "Usage: $0 manual_file"
    fi
}
vman () {
    if [ ! -z "$1" ]; then
        groff -man -Tascii $1 | less
    else
        echo "Usage: $0 manual_file"
    fi
}
cm () {
    mkdir "$1"
    cd "$1"
}
hr () {
     echo $1 | awk '
        BEGIN {
            hum[1024**5] = "Pb";
            hum[1024**4] = "Tb";
            hum[1024**3] = "Gb";
            hum[1024**2] = "Mb";
            hum[1024] = "Kb";
        }
        {
            num = $1;
            for (x = 1024**5; x >= 1024; x /= 1024) {
                if (num >= x) {
                    printf "%.2f %s\n", num/x, hum[x];
                    break;
                }
            }
        }'
}
days-ago() {
    if [ $# -eq 1 ]; then
        python -c "from datetime import date, timedelta; print date.today() - timedelta(days=$1)"
    elif [ $# -eq 2 ]; then
        python -c "from datetime import datetime, timedelta; print datetime.strptime('$1', '%Y-%m-%d').date() - timedelta(days=$2)"
    else
        echo "Usage: $0 [date-count-from] num-of-days" 1>&2
        return 1
    fi
}
#
#vv () {
#    file="$1"
#    mime_type=`file --brief --mime-type $file`
#    type_group=${mime_type%%/*}  # 'image/jpeg' → 'image' and so on
#    echo $file": "$type_group
#}
